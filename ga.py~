
import random

from main import HRMAsm
from HRMEvals import mail_room_eval

def weighted_random_choice(population):
    tot_fit = 0
    for i in population:
        tot_fit += i.fitness
    pick = random.uniform(0, tot_fit)
    current = 0
    for individual in population:
        current += individual.fitness
        if current > pick:
            return individual

def generate_init_pop(size, struct_set, board_size):

    pop = []

    for i in range(size):
        temp = HRMAsm(struct_set, board_size)
        temp.generate_asm()
        pop.append(temp)

    return pop


def evaluate_fitness(population, fit_eval):
    for i in pop:
        fit_eval(i)
        if i.fitness >= 1:
            print "one"
        
def cull_pop(population, pop_reduc):
    for i in range(pop_reduc):
        j = weighted_random_choice(population)
        print "Removing", j
        
def generate_gen(population, pop_inc, struct_set, board_size):
    new_pop = []
    for i in range(pop_inc):
        temp = HRMAsm(struct_set, board_size)
        temp.generate_asm()
        mutate_asm(temp)
        new_pop.append(temp)

def mutate_asm(individual):
    if random.random() < 0.2:
        individual.add_new_instruction()
    if random.random() < 0.2:
        individual.remove_random_instruction()

if __name__ == "__main__":

    instruct_set = ['inbox', 'outbox']

    pop = generate_init_pop(100, instruct_set, 0)

    for i in range(10):
        evaluate_fitness(pop, mail_room_eval)
        cull_pop(pop, 30)
    
        generate_gen(pop, 30, instruct_set, 0)

        for i in pop:
            print i.fitness

    best_answer = max(pop, key = lambda x : x.fitness)

    print "Best answer"
    print best_answer, best_answer.fitness
    
